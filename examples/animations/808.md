# 808 animation

ðŸš¨ _You can run this markdown file directly with the coldtype command line tool: `coldtype examples/animations/808.md`_ ðŸš¨ 

For this animation, we'll need the standard coldtype library as well as some optional bits, the `MidiReader` and the `warp_fn` from the warping library.

```python
from coldtype import *
from coldtype.animation.midi import MidiReader
from coldtype.warping import warp_fn
```

Though itâ€™s not necessary to load the font directly from the `.designspace` file (since we could always load an actual variable ttf file), it is fun to demonstrate.

```python
obvs = Font("assets/ColdtypeObviously.designspace")
```

Here the `MidiReader` comes into play â€” this is a class that parses midi files and converts the native time values to more useful frame-based time-values, based on a frame-per-second (`fps`) value.

This is also useful to load before the render function, because this MIDI data doesnâ€™t change once our program is loaded.

```python
drums = MidiReader("examples/animations/media/808.mid", duration=120, bpm=120, fps=30)[0]
```

I like to keep things like logos in UFO source files, since they arenâ€™t really typographic, so you donâ€™t need to load them as fonts. Here we load a ufo of logos via `DefconFont`, which makes keyed lookups of vectors very easy.

```python
logos = DefconFont("assets/logos.ufo")
```

OK, hereâ€™s the main render function. To start this off, we'll define variables for `kick` and `cowbell`, since we'll be referencing those when we build the initial text lockup in the next code block.

The `fv` method is a little cryptic, but weâ€™re looking for `(f)rame-(v)alues` for given MIDI notes, the `[36]` and `[47]` respectively. (Drumkits in Ableton Live usually begin on 36, so thatâ€™s usually where youâ€™ll find the kick when reading a MIDI file generated by Ableton.)

```python
@animation(duration=drums.duration, bg=0.2, storyboard=[105])
def drummachine(f):
    kick = drums.fv(f.i, [36], [5, 50])
    cowbell = drums.fv(f.i, [47], [15, 75])
```

Now we can build the initial `Style` specification, using the MIDI values for kick and cowbell to control the tracking (`tu`), and the `wdth` of the variable font, via the `.ease()` function available on the object returned from an `.fv` call.

We can also re-kern the T/Y for this particular use, since the text is so big, and when it gets stroked later on, we can avoid having a too-large visual mass in the composition. (Also itâ€™s fun to demonstrate that you can easily re-kern fonts with the `kp=` keyword and a dictionary of glyph-name pairs. (`kp` stands for kern-pairs.))

```python
    style = Style(obvs,
        390,
        tu=-150+550*cowbell.ease(),
        wdth=1-cowbell.ease()*0.75,
        ro=1,
        r=1,
        kp={"T/Y":-25})
```

Now with the `style` variable settled, we can construct a multi-line text lockup with the `Composer` class, by passing in a rectangle to hold the lockup, then the text itself, and the style object we created above.

We can also set the leading of the multi-line setting here, by specifying `leading=` as a function of the kick signal.

```python
    pens = (Composer(f.a.r,
        "COLD\nTYPE",
        style,
        leading=math.floor(10+kick.ease()*50))
        .pens()
        .align(f.a.r))
```

So now weâ€™ve got the lockup, and we move from _building_ the text to _messing_ with it, since we converted from the "text" realm to the "vector" realm with that `.pens()` call above. This is analogous to hitting "Convert to Outlines" in Illustrator (except in this case, if we want to change the text later, itâ€™s easy).

Anyway, the point is now we have a hierarchical representation of the text that we can query and modify, kind of like manipulating a DOM via css or js if you're familiar with web tech.

To start, letâ€™s visualize the snare hits by shearing the line composition & rotating the two letters that correspond to where the snares hit in an 8-count. That's a fancy way of saying, the eight letters here correspond to the 8 eighth-notes in the bar, so we want to modify letters 3 and 7 (aka `P` and `L`), which correspond to the snare hits.

A few notes:

- `ffg` stands for `find-first-glyph`, which finds the first glyph with the given name. So we want to find the L in the first line of text, thatâ€™s `pens[0].ffg("L")`; we want to find the P on the second line, thatâ€™s `pens[1].ffg("P")`, etc.

- `mod_contour` allows you to modify a nested pen value in-place as a set of contours with a callback function (aka a `lambda`). Basically, the `mod_contour` function first "explodes" the glyph into all its component contours (in the Pâ€™s case, thatâ€™s the outer shape & the counter shape), and then gives you an opportunity to modify just the specified contour before reassembling the contours into the letter (so the counter is still a counter and not just another filled-in shape). Thatâ€™s how weâ€™re able to keep the counter of the P frozen in place. If we got rid of the `mod_contour` call and instead rotated the P glyph itself (ala `pens[1].ffg("P").rotate(rim.ease()*-270)`), then the counter shape would also rotate.


```python
    snare = drums.fv(f.i, [40], [10, 40])
    se = snare.ease()

    if snare.count == 1: # the first snare hit
        pens[0].translate(-150*se, 0)
        pens[1].translate(150*se, 0)
        pens[0].ffg("L").rotate(se*-270)
    else: # the second snare hit
        pens[0].translate(150*se, 0)
        pens[1].translate(-150*se, 0)
        (pens[1]
            .ffg("P")
            .mod_contour(0, lambda c:
                c.rotate(snare.ease()*270)))
```

Whew, ok that was a little complicated. Now letâ€™s do something similar with `mod_contour` on the P, but this time rotate just the counter shape when the second rimshot hits (we can ignore the first rimshot b/c it hits at the same time as a hi-hat, which we'll visualize in a second).

```python
    rim = drums.fv(f.i, [39], [5, 5])
    if rim.count == 2:
        (pens[1]
            .ffg("P")
            .mod_contour(1, lambda c:
                c.rotate(rim.ease()*-270)))
```

Wouldnâ€™t it be cool if the letters corresponding to the kicks scaled up whenever the kick hit? Thatâ€™s whatâ€™s happening here, along with a more programmer-y idiom, i.e. unpacking a tuple to the `line, glyph`. This is just a way of abbreviating a longer `if-else` statement that would contain redundant code.

```python
    line, glyph = (0, "C") if kick.count == 1 else (1, "Y")
    (pens[line]
        .ffg(glyph)
        .scale(1+0.5*kick.ease()))
```

OK, on to the hi-hats. Here we get the hat signal from the midi, with an even preverb-reverb (thatâ€™s the `[10, 10]` bit), because we want to mimic the regular action of a drummer hitting a hi-hat.

```python 
    hat = drums.fv(f.i, [43], [10, 10])
```

When the first hat hits, letâ€™s move the counter in the O to the right.

```python
    if hat.count == 1:
        (pens[0]
            .ffg("O")
            .mod_contour(1, lambda c:
                c.translate(80*hat.ease(), 0)))
```

And when the second hat hits, letâ€™s move the counter of the D in the first line, this time translating it down & then rotating it, to make it seem like itâ€™s falling and then bouncing back up from the bottom of the outer shape.

```python 
    elif hat.count == 2:
        (pens[0]
            .ffg("D")
            .mod_contour(1,
                lambda c: (c
                    .translate(-30*hat.ease(), -100*hat.ease())
                    .rotate(hat.ease()*110))))
```

And when the third and fourth hats hit, letâ€™s move the left and right sides of the T crossbar, via the `map_points` function, which lets you adjust the x and y values of a shape directly via a callback.

```python
    elif hat.count in [3, 4]:
        
        def move_t_top(idx, x, y):
            if hat.count == 3 and 0 <= idx <= 6:
                return x-150*hat.ease(), y
            elif hat.count == 4 and 22 <= idx <= 30:
                return x+150*hat.ease(), y

        pens[1].ffg("T").map_points(move_t_top)
```

Ok last hat! Here we exaggerate the horizontality of the E counters with the same `map_points` function.

```python
    elif hat.count == 5:
        
        def move_e_contour(idx, x, y):
            if 9 <= idx <= 13 or 20 <= idx <= 25:
                x -= 75*hat.ease()
            return x, y
        
        pens[1].ffg("E").map_points(move_e_contour)
```

The last visualization is the tom-tom hit. Here we can just nudge up the outer contour of the O in the first line.

```python
    tom = drums.fv(f.i, [50], [5, 10])
    (pens[0]
        .ffg("O")
        .mod_contour(0, lambda c:
            c.translate(0, -80*tom.ease())))
```

And a little branding: load the Goodhertz logo from the ufo via `glyph` and apply a `nonlinear_transform` to it, using the `warp_fn` helper. This lets you quickly & easily apply a "wavey" Perlin noise transformation. To be honest I barely understand how it works, but it looks cool.

```python
    fp = f.a.prg(f.i, easefn="linear").e
    ghz_logo = (DATPen()
        .glyph(logos["goodhertz_logo_2019"])
        .scale(0.2)
        .align(f.a.r, y="mny")
        .translate(0, 100)
        .nonlinear_transform(warp_fn(speed=fp*3, rz=3, mult=10))
        .skew(cowbell.ease()*1))
```

Now we return the data weâ€™ve manipulated to the renderer. This is also where we apply the finishing touches to the `COLD\nTYPE` lockup, by reversing the lines so that the the first line is last (meaning it shows up on top, which is nice for when the C gets really big), and then by applying an `understroke`, which interleaves stroked copies of each letter in the composition, giving us a classic look that we can hit with a high-contrast `phototype` simulation. And then weâ€™re done!

```python
    return DATPenSet([
        (DATPen()
            .rect(f.a.r)
            .f(Gradient.V(f.a.r,
                hsl(0.58, 0.55, 0.5),
                hsl(0.65, 0.55, 0.5)))
            .f(0)),
        ghz_logo.f(hsl(0.9, 0.55, 0.5)),
        (pens.f(1)
            .reversePens()
            .translate(0, 100)
            .pmap(lambda i, p: 
                (p.flatten(3).nlt(warp_fn(f.i*10, f.i*10, mult=30)))
            .understroke(s=0, sw=15)
            .phototype(SkiaPen,
                f.a.r.scale(2),
                blur=5, cut=190, cutw=8,
                context=__CONTEXT__,
                fill=1))])
```